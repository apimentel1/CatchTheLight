# Purpose of this page
The documentation included in this wiki outlines the process taken to complete the Catch the Light PCB Project. In addition to writing about the knowledge gained from software and datasheets utilized for this project, all of the challenges that were encountered were also discussed.

# Documentation for Phase 1
For the first phase of the design project, the team was given the challenge of recreating the interactive “stop the light” game in the display case located in the SENG hallway made by Justin Meninno, a former ECE student at the University of Massachusetts Dartmouth. To understand the depth of the project, a list of requirements (**requirement document link**) was made based upon Dr. Viall’s vision of the project. The overall vision for the project was to recreate the game on a PCB, solely using surface-mount 7400 series discrete logic components. The reason for doing so was to recreate the game with the exact same components used on the bread-boarded version of the game. In order to begin the first phase of the project, it was critical to understand the game’s circuitry and how it worked using discrete logic. To do so, three different circuit design software programs were utilized: Fritzing, Multisim, and Eagle. 

## Using Fritzing
Fritzing is an advanced software tool used by designers and engineers alike to transition projects and ideas into a functional prototype. The features that were specifically utilized were the schematic and digital breadboard features. The purpose of using this software was to create a breadboarded schematic of the original game. An image of what the project looked like can be seen in the image below.

**PUT IMAGE OF ORIGINAL CATCH THE LIGHT GAME HERE**

What made the design of the original Catch the Light game so compelling is that it was designed with using only 7400 series discrete logic. To figure out how the circuit operated, it was crucial that a schematic was created to help reverse engineer the game and figure out how it worked, which was why Fritzing was useful. The first step to creating the Fritzing schematic was to analyze the game in the laboratory and identify the 7400 series chips that were being used on the board. A table with the name of each chip in addition to their respective amounts can be seen in **Table_** below.

**PUT IMAGE OF 7400 SERIES CHIP TABLE HERE**

 When trying to search for these components in Fritzing’s parts library, it became apparent that Fritzing’s library wasn’t as advanced as the libraries of its competitors. To compensate for this issue, each of the chips had to be custom made using Fritzing’s “Parts editor” tool. This made the process of recreating the circuit in Fritzing much more involved than expected.

To make a custom IC, the first step that had to be done was clicking on the Core tab in the parts window and scrolling down until the ICs section came into view. Following this, The IC icon was clicked and dragged onto the breadboard window to import the part into the project. After clicking the Inspector window and clicking on the IC properties tab, the name and number of pins on the IC chip could be changed. This process was done for each chip on the board. As for the other components in the project, they were all included in Fritzing’s parts and components library, so they were added into the project normally. A table that includes the name of each component as well as their quantity can be seen in **Table_** below. With all the components imported into the project, the schematic was able to be made and the breadboard schematic was wired after. 

**TABLE OF OTHER COMPONENETS ON BOARD**

## Challenges Involved With Fritzing	
Using Fritzing was great for recreating the project on the breadboard, however it didn’t come without its challenges. The biggest problem that we had using Fritzing was with making the schematic. The wire routing on the schematic portion wasn’t very user friendly as compared to Eagle and Multisim. When placing the components onto the 3D breadboard, positioning the legs for capacitors and resistors was made abnormally difficult. Maneuvering the mouse cursor over the legs would frequently route a wire and not recognize that the leg was the component trying to be repositioned. One visual problem with the 3D breadboard involved the positioning of the LEDs. Visually, they are “sent to back” therefore at any other component also “sent to back” would get overlaid by the LED and wouldn’t be visible. With this problem, repositioning the legs of components was tedious. The finished product of the breadboard schematic can be seen below in **Figure_**.

**IMAGE OF FRITZING BREADBOARD CIRCUIT**

## Using Multisim
Although Multisim wasn’t required to be used in this project, a schematic of the game was still created with Multisim. The reason behind doing so was to have the ability  to simulate the circuit. Due to Eagle and Fritzing not having the ability to simulate the circuit to check if it was operational, Multisim was the best choice to test whether the schematics we made were correct. This ended up helping our group catch a wiring error that was made in the original schematic seeing as one of the 555 timers wasn’t wired properly. In addition, the simulation software was the main tool that was used to understand how each of the components worked together to make the game work the way that it does. The functional schematic of the project that was created on Multisim can be seen in **Figure_**.

**IMAGE OF MULTSIM CIRCUIT HERE**

## How the breadboarded version of the Catch the Light Works
It was found that at startup, one of the 555 timers (U2) free runs as a multivibrator at 15Hz which in turn makes the LEDs cycle around in a circular pattern. The frequency calculation for the multi-vibrator is f=1/T=1.44/(R_A+2R_B )C=1.44/((2200+2(1000)).000022)=15.58Hz. This frequency calculation represents the speed at which the light “travels” in the circular pattern.  In other words, the LED is high for 15.58 seconds and then low for 15.58 seconds.
	Next, a second 555 timer (U5) operates in a monostable state which has the timer function as a one shot. Normally, this 555 timer’s output is low which allows itself to freely run while the third 555 timer (U7) is held in reset. When the button is pressed by the user, the second 555 timer’s (U5) output goes high for 5.17 seconds (t=1.1R_A C=(1.1)(47000)(.0001)=5.17seconds). When it goes high, pin 2 on the inverter (U6) goes low which stops the first 555 timer (U2) from running for 5.17 seconds. This action freezes the light at the location it was currently at when the button was pressed.  If pin 12 on the 3-8 Decoder (U4) (the signal for the yellow light) goes low along with the signal received from the user’s button press, then pins 3 and 9 on the second 555 timer (U5) also go low which in turn makes their outputs high. If they are high, this will make the third 555 timer (U7) run as a multivibrator at 1.6Hz, f=1/T=1.44/(R_A+2R_B )C=1.44/((2200+2(6600)).0001)=1.63Hz. As a result, all the lights will flash at this frequency to show that the user won by stopping the light in the correct spot. If Led 1 wasn’t on when the button was pressed, then the third 555 timer (U7) wouldn’t be enabled and the light would just pause for 5.17 seconds, signaling that the user didn’t win. After the time passes, the light from the LEDs will start cycling around again waiting for the next button press.
	 The purpose of the synchronous 4 bit counter (U3) in the game is to turn the clock pulses from the first 555 timer (U2) into a counter that counts from 0 to 7. The 3 outputs from the counter become inputs to the 3-8 decoder (U4) and each count from the counter lights the corresponding output to feed to the LEDs. The two quadruple 2-input AND gate chips (U8 and U9) are used to light the LEDs from the decoder or from the third 555 timer (U7) when the user presses the button while the yellow LED is lit.

## Using Eagle to make the circuit's schematic
The easiest and most important schematic of this phase of the project was made using the EAGLE software. EAGLE stands for Easily Applicable Graphical Layout Editor, which allows users to make printed circuit boards (PCBs) based on wiring schematics designed by the user. EAGLE also allows users to manufacture their PCB designs using computer-aided manufacturing (CAM) features.

To recreate the original game on a PCB, EAGLE was required to be used. The schematic that was previously made in Multisim was made once again, but in EAGLE’s schematic designer. Before going into EAGLE’s parts library and importing the desired 7400 series discrete logic chips into the schematic, it was important to look at each chip’s respective datasheet **(Chip Data Sheets Link)**. The reason for doing so was to understand the pin out for each chip as well as their electrical characteristics. Electrical characteristics such as supply voltage, supply current, output voltage, and temperature accuracy were important to note. The purpose of doing so was to be sure that the PCB could properly power each component on the board . All surface mount (SMD) footprints were used so that the pick and place machine could be used in the future. As for the resistors and capacitors used in the schematic, their footprints were also selected to be SMD and of size 0805 which is the standard size of components used in the industry. As per the requirements, it was specified that the PCB would operate on a 12V constant voltage supply. To do so, a voltage regulator had to be added into the EAGLE schematic. After researching different voltage regulators that were available in EAGLE’s parts library, the data sheet for the MC7800 positive voltage regulator made by ON Semiconductor was viewed. The information that was the most important to note was the regulator’s “Maximum Ratings” table on page one of the data sheet. After seeing that the input voltage range was from 5V – 18V, it was safe to say that the voltage regulator could easily handle the required 12V. The data sheet for the voltage regulator can be seen here. **(Regulator Link)**.
	
The next requirement that had to be considered was that the PCB would have to have the ability to operate with a pushbutton located on the outside of the display case so that users  could interact with the game. The easiest way to accomplish this was by putting an external pushbutton connector on the board. After importing the desired external connector for the PCB into the schematic, it was important to wire it in parallel so that the external pushbutton would not interfere with the button on the PCB . To accomplish this, the output voltage from the voltage regulator was connected to the input pin on the connector while the pushbutton pin was connected to the pushbutton located on the PCB. After routing all of the wires in the schematic, the electrical rule check (ERC) was ran to check for any errors or warnings in the schematic that would prevent the device from operating correctly. Once the ERC check passed, the PCB was able to be built by switching from schematic mode to board mode in EAGLE.

**PUT PICTURE OF EAGLE SCHEMATIC HERE**











