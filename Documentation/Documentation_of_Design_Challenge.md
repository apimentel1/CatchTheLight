# Purpose of this page
The documentation included in this wiki outlines the process taken to complete the Catch the Light PCB Project. In addition to writing about the knowledge gained from software and datasheets utilized for this project, all of the challenges that were encountered were also discussed.

# Documentation for Phase 1
For the first phase of the design project, the team was given the challenge of recreating the interactive “stop the light” game in the display case located in the SENG hallway made by Justin Meninno, a former ECE student at the University of Massachusetts Dartmouth. To understand the depth of the project, a list of requirements (**requirement document link**) was made based upon Dr. Viall’s vision of the project. The overall vision for the project was to recreate the game on a PCB, solely using surface-mount 7400 series discrete logic components. The reason for doing so was to recreate the game with the exact same components used on the bread-boarded version of the game. In order to begin the first phase of the project, it was critical to understand the game’s circuitry and how it worked using discrete logic. To do so, three different circuit design software programs were utilized: Fritzing, Multisim, and Eagle. 

## Using Fritzing
Fritzing is an advanced software tool used by designers and engineers alike to transition projects and ideas into a functional prototype. The features that were specifically utilized were the schematic and digital breadboard features. The purpose of using this software was to create a breadboarded schematic of the original game. An image of what the project looked like can be seen in the image below.

**PUT IMAGE OF ORIGINAL CATCH THE LIGHT GAME HERE**

What made the design of the original Catch the Light game so compelling is that it was designed with using only 7400 series discrete logic. To figure out how the circuit operated, it was crucial that a schematic was created to help reverse engineer the game and figure out how it worked, which was why Fritzing was useful. The first step to creating the Fritzing schematic was to analyze the game in the laboratory and identify the 7400 series chips that were being used on the board. A table with the name of each chip in addition to their respective amounts can be seen in **Table_** below.

**PUT IMAGE OF 7400 SERIES CHIP TABLE HERE**

 When trying to search for these components in Fritzing’s parts library, it became apparent that Fritzing’s library wasn’t as advanced as the libraries of its competitors. To compensate for this issue, each of the chips had to be custom made using Fritzing’s “Parts editor” tool. This made the process of recreating the circuit in Fritzing much more involved than expected.

To make a custom IC, the first step that had to be done was clicking on the Core tab in the parts window and scrolling down until the ICs section came into view. Following this, The IC icon was clicked and dragged onto the breadboard window to import the part into the project. After clicking the Inspector window and clicking on the IC properties tab, the name and number of pins on the IC chip could be changed. This process was done for each chip on the board. As for the other components in the project, they were all included in Fritzing’s parts and components library, so they were added into the project normally. A table that includes the name of each component as well as their quantity can be seen in **Table_** below. With all the components imported into the project, the schematic was able to be made and the breadboard schematic was wired after. 

**TABLE OF OTHER COMPONENETS ON BOARD**

## Challenges Involved With Fritzing	
Using Fritzing was great for recreating the project on the breadboard, however it didn’t come without its challenges. The biggest problem that we had using Fritzing was with making the schematic. The wire routing on the schematic portion wasn’t very user friendly as compared to Eagle and Multisim. When placing the components onto the 3D breadboard, positioning the legs for capacitors and resistors was made abnormally difficult. Maneuvering the mouse cursor over the legs would frequently route a wire and not recognize that the leg was the component trying to be repositioned. One visual problem with the 3D breadboard involved the positioning of the LEDs. Visually, they are “sent to back” therefore at any other component also “sent to back” would get overlaid by the LED and wouldn’t be visible. With this problem, repositioning the legs of components was tedious. The finished product of the breadboard schematic can be seen below in **Figure_**.

**IMAGE OF FRITZING BREADBOARD CIRCUIT**

## Using Multisim
Although Multisim wasn’t required to be used in this project, a schematic of the game was still created with Multisim. The reason behind doing so was to have the ability  to simulate the circuit. Due to Eagle and Fritzing not having the ability to simulate the circuit to check if it was operational, Multisim was the best choice to test whether the schematics we made were correct. This ended up helping our group catch a wiring error that was made in the original schematic seeing as one of the 555 timers wasn’t wired properly. In addition, the simulation software was the main tool that was used to understand how each of the components worked together to make the game work the way that it does. The functional schematic of the project that was created on Multisim can be seen in **Figure_**.

**IMAGE OF MULTSIM CIRCUIT HERE**

## How the breadboarded version of the Catch the Light Works
It was found that at startup, one of the 555 timers (U2) free runs as a multivibrator at 15Hz which in turn makes the LEDs cycle around in a circular pattern. The frequency calculation for the multi-vibrator is f=1/T=1.44/(R_A+2R_B )C=1.44/((2200+2(1000)).000022)=15.58Hz. This frequency calculation represents the speed at which the light “travels” in the circular pattern.  In other words, the LED is high for 15.58 seconds and then low for 15.58 seconds.

Next, a second 555 timer (U5) operates in a monostable state which has the timer function as a one shot. Normally, this 555 timer’s output is low which allows itself to freely run while the third 555 timer (U7) is held in reset. When the button is pressed by the user, the second 555 timer’s (U5) output goes high for 5.17 seconds (t=1.1R_A C=(1.1)(47000)(.0001)=5.17seconds). When it goes high, pin 2 on the inverter (U6) goes low which stops the first 555 timer (U2) from running for 5.17 seconds. This action freezes the light at the location it was currently at when the button was pressed.  If pin 12 on the 3-8 Decoder (U4) (the signal for the yellow light) goes low along with the signal received from the user’s button press, then pins 3 and 9 on the second 555 timer (U5) also go low which in turn makes their outputs high. If they are high, this will make the third 555 timer (U7) run as a multivibrator at 1.6Hz, f=1/T=1.44/(R_A+2R_B )C=1.44/((2200+2(6600)).0001)=1.63Hz. As a result, all the lights will flash at this frequency to show that the user won by stopping the light in the correct spot. If Led 1 wasn’t on when the button was pressed, then the third 555 timer (U7) wouldn’t be enabled and the light would just pause for 5.17 seconds, signaling that the user didn’t win. After the time passes, the light from the LEDs will start cycling around again waiting for the next button press.
	
The purpose of the synchronous 4 bit counter (U3) in the game is to turn the clock pulses from the first 555 timer (U2) into a counter that counts from 0 to 7. The 3 outputs from the counter become inputs to the 3-8 decoder (U4) and each count from the counter lights the corresponding output to feed to the LEDs. The two quadruple 2-input AND gate chips (U8 and U9) are used to light the LEDs from the decoder or from the third 555 timer (U7) when the user presses the button while the yellow LED is lit.

## Using Eagle to make the circuit's schematic
The easiest and most important schematic of this phase of the project was made using the EAGLE software. EAGLE stands for Easily Applicable Graphical Layout Editor, which allows users to make printed circuit boards (PCBs) based on wiring schematics designed by the user. EAGLE also allows users to manufacture their PCB designs using computer-aided manufacturing (CAM) features.

To recreate the original game on a PCB, EAGLE was required to be used. The schematic that was previously made in Multisim was made once again, but in EAGLE’s schematic designer. Before going into EAGLE’s parts library and importing the desired 7400 series discrete logic chips into the schematic, it was important to look at each chip’s respective datasheet **(Chip Data Sheets Link)**. The reason for doing so was to understand the pin out for each chip as well as their electrical characteristics. Electrical characteristics such as supply voltage, supply current, output voltage, and temperature accuracy were important to note. The purpose of doing so was to be sure that the PCB could properly power each component on the board . All surface mount (SMD) footprints were used so that the pick and place machine could be used in the future. As for the resistors and capacitors used in the schematic, their footprints were also selected to be SMD and of size 0805 which is the standard size of components used in the industry. As per the requirements, it was specified that the PCB would operate on a 12V constant voltage supply. To do so, a voltage regulator had to be added into the EAGLE schematic. After researching different voltage regulators that were available in EAGLE’s parts library, the data sheet for the MC7800 positive voltage regulator made by ON Semiconductor was viewed. The information that was the most important to note was the regulator’s “Maximum Ratings” table on page one of the data sheet. After seeing that the input voltage range was from 5V – 18V, it was safe to say that the voltage regulator could easily handle the required 12V. The data sheet for the voltage regulator can be seen here. **(Regulator Link)**.
	
The next requirement that had to be considered was that the PCB would have to have the ability to operate with a pushbutton located on the outside of the display case so that users  could interact with the game. The easiest way to accomplish this was by putting an external pushbutton connector on the board. After importing the desired external connector for the PCB into the schematic, it was important to wire it in parallel so that the external pushbutton would not interfere with the button on the PCB . To accomplish this, the output voltage from the voltage regulator was connected to the input pin on the connector while the pushbutton pin was connected to the pushbutton located on the PCB. After routing all of the wires in the schematic, the electrical rule check (ERC) was ran to check for any errors or warnings in the schematic that would prevent the device from operating correctly. Once the ERC check passed, the PCB was able to be built by switching from schematic mode to board mode in EAGLE.

**PUT PICTURE OF EAGLE SCHEMATIC HERE**

## Designing the Phase 1 PCB
Due to forward and backward annotation on EAGLE, all the components were automatically imported into the board design window. In addition, any changes that were made to the schematic automatically changed in the PCB design and vice-versa. As per the requirements, the size of the board couldn’t be larger than 10 x 10 cm. This was not a hard requirement to fulfill since the size of the components on the PCB were small. One problem that was noticed after routing all the traces on the PCB was that many of the trace lengths were longer than they had to be. Long traces increase signal propagation time and may contribute to power loss and signal loss, which is not ideal when designing PCBs. In addition, longer runs are also more susceptible to interference. To fix this error, the components on the board were reorganized to shorten the distance each trace had to travel. For traces that could not be shortened so easily, using via’s proved to be the most effective solution. After the board was complete, EAGLE’s DRC check was ran to see if the board would be able to be manufacturable. After the check passed, the wiring on the board was compared to the schematic while also making sure that the layout of the PCB was visually appealing. Once the team felt comfortable with the design, the Gerber files were made as seen below. 

**FRONT SIDE OF GERBER PICTURE HERE**

**BACK SIDE OF GERBER PICTURE HERE**

After generating the Gerber files in Eagle, one issue that was originally noticed was that the silkscreen text in the rendered image of the board was quite small. After clicking on the properties for the silkscreen text, it was found that the text would have to be increased in size to be manufacturable by the board house. After this error was fixed, the board was ready to be manufactured. Due to the Phase 2 board being the main focus of this project, the PCB for phase 1 was not manufactured, however it will be able to be manufactured whenever needed since the Gerber files were assembled correctly.

# Documentation for Phase 2

For Phase 2 of the project, our group was tasked with creating a more advanced version of the game that operated using the Atmega328PB microcontroller. The requirements for Phase 2 (**Put link here for Phase 2 Requirements**) also specified that a capacitive touch button incorporated into the PCB design was to be used in the place of a regular pushbutton. In addition, the game would have to operate off a single coin cell battery that could automatically power off the game after 30 seconds of no user activity. Before making a schematic in EAGLE to make a prototype of the PCB, it was important to read the datasheet for the Atmega328PB (**Atmega Datasheet link**).

Although all the members in the group have previously used the Atmega328PB and have had experience using the datasheet, no one had ever interfaced a capacitive touch button with the chip. On page 306 of the datasheet, information pertaining to the peripheral touch controller (PTC) was able to be found. The first piece of critical information found was an explanation of how capacitive touch buttons work. It was learned that when the user’s finger makes contact with the PTC, the user’s finger acts as a virtual ground. When a connection between the user’s finger and capacitive touch button is made, a change in the dielectric is registered which signals that the button is being pressed. It was also noted that to increase performance of the button, a resistor in series ranging from 1kΩ to 1MΩ could be used. This was an important fact that played a role into the design of the PCB so that the board would respond to the user’s touch in less than 0.1 seconds, which was one of the requirements for the project. The second most critical piece of information obtained was that Atmel Start Q-Touch library had to be used in conjunction with the compiler when writing code for it.

**Q-TOUCH LIBRARY FLOWCHART**

To be sure that a 3V coin cell battery would have enough voltage to power the game, the power consumption of the Atmega328PB had to be considered. With the Atmega328PB operating at 1.8V - 5.5V, it was understood that the chip would operate fine on 3V. In addition to the Atmega chip, it was also important to test the forward voltage and nominal current of the 16 LEDs in the design. During the test, a red LED was used seeing as the blue and green LEDs had not yet arrived via mail. Upon testing the LED with a series resistance of 1.5kΩ, it was found that the forward voltage was 1.74V and the nominal current was 819.4mA. To make the LEDs as bright as possible, two different scenarios were tested. The first being the full 3V of the battery powering the LEDs and the second being 1.8V powering the LEDs. By testing the performance of the LEDs at 1.8V, the results observed would demonstrate what to expect with a dying battery. After conducting the test, it was found that exactly at 1.7V, the red LED’s shut off. This was not much of a problem considering that the Atmega328PB chip would also stop working at 1.8V. Since it was found that the LEDs didn’t consume much current it was confirmed that a 3V coin cell battery could power the PCB efficiently.

In the case that the user put the battery in backwards, it was important to include a feature that would protect the PCB from shorting out. The solution to this problem was using an PFET   seeing as it had less of a power loss  than if a diode was used instead. This theory was tested, and it was found that a died would have a voltage drop of 0.7V whereas the PFET was approximately 0.1V. After understanding the power consumption of the components that would be on the PCB, a schematic of the circuitry for the PCB was made in EAGLE which can be seen below.

**PAHSE 2 EAGLE SCHEMATIC**

## Special Features to Note in the Phase 2 Schematic

